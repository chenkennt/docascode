Doc-as-Code: Metadata Format Specification
==========================================

0. Design Notes
---------------

### 0.1 Terms

The terms **MUST**, **MUST NOT**, **SHOULD**, **SHOULD NOT**, **MAY** (upper case and bold in this document) have exactly the same meaning as they are described in [RFC 2119][1].

Words in *italic* imply they are terms defined in earlier section of this document.

### 0.2 Language Agnostic

// TODO

1. Items and Identifiers
------------------------

### 1.1 Items

Item is the basic unit of metadata format. Each item represent a section in your document.
And it's the minimum unit that you can cross reference inside your documentation.

For example, in C#, namespaces, classes, methods are all items.

### 1.2 Scopes

*Items* can be hierarchical. One *item* can have other *items* as children.
For example, in C#, namespaces and classes are scopes, as they can have child classes and/or methods.

*Items* with children are called **scopes**.

> Essentially all *items* are scopes. Just in different programming languages some cannot have children.  

There are two special scopes:
1. For an item, its parent is called "local scope".
2. Global scope is a logical concept that contains all top-level items.

### 1.3 Identifiers (ID)

Identifier (ID) is the name of *items*. For one item, its ID is unique under *local scope*.

There is no special rules that which characters are valid in identifier, except for whitespaces.
Whitespaces are allowed in identifiers, but they **MUST** be normalized before comparing equality:
1. If whitespaces is connecting two "word" characters, replace them with a single space (word character is defined by regex `[A-Za-z0-9_]`).
2. Otherwise remove the whitespaces.

For example, the following IDs are the same:
1. `Equals (string, string)` and `Equals(string,string)`
2. `operator int()` and `operator  int( )`

### 1.4 Unique Identifiers (UID)

*Identifier* is only unique under *local scope*, while unique identifier (QID) is unique under *global scope*.

For an *item*, its UID is generated by concatenating the *ID* of the *item* itself, its parent *scope*, and all its ancestor *scopes*, separated by characters called "separator".

Or we can use a recursive definition: an *item*'s UID is generated by concatenating the UID of its parent *scope*, a separator and the *ID* of the *item* itself.

Valid separators are `.`, `:`, `/` and `\`.

For example, an *item* `ToString()` is under *scope* `Object`, which is under *scope* `System`, then its *UID* is `System.Object.ToString()`.

> Given the above definition, an *item*'s UID **MUST** starts with the UID of its *scope*. This is useful to quickly determine whether an *item* is under a certain scope.

### 1.5 Alias

Given *ID* may be very long, especially in languages with function overloads, a function's *ID* usually consists of the function name, and the *UIDs* of all its parameters.

We can create short alias for *items* so that they can be referenced easily.

Alias is similar to *ID*, just they don't have to be unique in *local scope*, multiple *items* can have the same alias.
When reolving alias, it's up to the resolver to return all *items* with the same alias or just one of them.

A local alias can be easily converted to a global one by replacing the *ID* part in *UID* with alias.

One useful scenario for alias is function overload. For example, a function's *ID* may look like this:
```
Format(System.IFormatProvider,System.String,System.Object,System.Object)
```
It will be too long if user wants to use this reference the function.
Usually user may want to reference a function using its name. To achieve this, we can create an alias for this function using its name only: `Format()`.

### 1.6 Reference Item by ID, UID and Alias

*ID*, *UID* and *alias* are designed to 

### Overload
Overload is a group of *items* which have the same *ID* under a *scope*. This is a common concept in many programming languages.
For example, in C#, function `Equals()` may have the following overloads:
```csharp
bool Equals(object);
bool Equals(string);
bool Equals(string, string);
bool Equals(string, StringComparison);
bool Equals(string, string, StringComparison);
```

All these methods will have the same *ID*, but with an overload section to distinguish between different overloads.
Overload section **MUST** be surrounded by overload separator.

Valid overload separator are `()`, `[]` and `{}`.

Overload section **MAY** contain a list of *QIDs*, which are separated by separators (valid separators are `,`, `

> An algorithm **SHOULD** be implemented to allow match *QID* without overload section.
> For example, user can write `Equals` to match one of the overload function of Equals.

> When designing *QID* for your own languages, it's **RECOMMENDED** to always include overload separators if the type of item supports overload,
> no matter the *item* itself is overloaded or not. For example, use `ToString()` instead of `ToString` even it's not overloaded.

### Whitespaces
*QID* can contain whitespace, but they will be ignored when comparing equality.

For example, 
`Equals (string, string)` and `Equals(string,string)` are same *QID*.

### ID in C# 

#### Types
1. Predefined types: `object`, `string`, `int`, etc.
2. Simple types: `System.Exception`
3. Generic types: ``System.Collections.Generic.IEnumerable`1``, ``System.Collections.Generic.Dictionary`2``

#### Methods


`System.String.Equals(System.String, System.String)`
`String.Equals(String, String)`




#### Combined IDs
Combined ID is used to represent types like generic type instantiation.
Theoretically these types doesn't really exist, so these IDs are used to reference multiple APIs at the same time.  
For example:  
``System.Collections.Generic.IEnumerable`1<string>``  
``System.Collections.Generic.Dictionary`2<int, System.Exception>``


[1]: https://www.ietf.org/rfc/rfc2119.txt
